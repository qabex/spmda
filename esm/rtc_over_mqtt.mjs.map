{"version":3,"file":"rtc_over_mqtt.mjs","sources":["../code/rtc_handshake.jsy","../code/rtc_over_mqtt.jsy"],"sourcesContent":["\nexport default RTCHandshake\nexport class RTCHandshake ::\n  static with_peer(pc, send_msg) ::\n    return new this(pc, send_msg)\n\n  static create(send_msg) ::\n    return this.with_cfg(this.cfg_std(), send_msg)\n\n  static with_cfg(cfg, send_msg) ::\n    const pc = new RTCPeerConnection(cfg)\n    return this.with_peer(pc, send_msg)\n\n  static cfg_std() :: return @{}\n    sdpSemantics: 'unified-plan'\n    iceServers: @[]\n      @{} urls: 'stun:stun1.l.google.com:19302'\n\n\n  constructor(pc, send_msg) ::\n    if 'function' !== typeof send_msg :: throw new TypeError\n\n    this.pc = pc\n    this.send_msg = send_msg\n    pc.addEventListener @ 'icecandidate', this._evt_ice.bind(this, send_msg)\n\n    this.has_connected = new Promise @ on_connected => @\n      this.has_ended = new Promise @ on_ended => @\n        this.pc.addEventListener @ 'connectionstatechange',\n          this._evt_state.bind(this, on_connected, on_ended)\n\n  _evt_ice(send_msg, {candidate}) ::\n    if candidate ::\n      send_msg(candidate)\n\n  _evt_state(on_connected, on_ended) ::\n    switch this.pc.connectionState ::\n      case 'connected':\n        return on_connected(this)\n\n      case 'disconnected': case 'failed': case 'closed':\n        return on_ended(this)\n\n\n  async rtc_initiate() ::\n    const {pc} = this\n    const offer = await pc.createOffer()\n    await pc.setLocalDescription(offer)\n    await this.send_msg(offer)\n    return pc\n\n  async _rtc_offer(offer) ::\n    const {pc} = this\n    if null != pc.remoteDescription ::\n      return\n\n    await pc.setRemoteDescription(offer)\n\n    if null == pc.localDescription ::\n      const answer = await pc.createAnswer()\n      await pc.setLocalDescription(answer)\n      await this.send_msg(answer)\n\n  async _rtc_ice(msg) ::\n    const ice = new RTCIceCandidate(msg)\n    await this.pc.addIceCandidate(ice)\n\n  async on_rtc_msg(msg) ::\n    try ::\n      if msg.candidate ::\n        return await this._rtc_ice(msg)\n      else if msg.sdp ::\n        return await this._rtc_offer(msg)\n    catch err ::\n      this._on_msg_error(msg, err)\n\n  _on_msg_error(msg, err) ::\n    console.warn @ \"RTC error:\", err\n\n","import mqtt_v4 from 'https://cdn.jsdelivr.net/npm/u8-mqtt/esm/web/v4.mjs'\nimport {RTCHandshake} from './rtc_handshake.jsy'\n\n\nexport async function rtc_mqtt_server(opt) ::\n  opt.mqtt = mqtt_v4()\n    .with_websock(opt.websock)\n\n  await opt.mqtt.connect()\n  return _rtc_mqtt_server(opt)\n\n\nexport async function rtc_mqtt_client(opt) ::\n  opt.mqtt = mqtt_v4()\n    .with_websock(opt.websock)\n\n  await opt.mqtt.connect()\n  return _rtc_mqtt_client(opt)\n\n\n\nexport function _rtc_mqtt_server(opt) ::\n  const _bind_send = opt.bind_send || _bind_mqtt_send\n  const _bind_recv = opt.bind_recv || _bind_mqtt_recv\n\n  const _by_chan = new Map()\n\n  _bind_recv @ opt, `${opt.topic}/m/:chan_id`,\n    @\\ pkt, {chan_id} ::>\n      let rtc = _by_chan.get(chan_id)\n      if undefined === rtc ::\n        rtc = await _init_handshake(chan_id)\n\n      await rtc.on_rtc_msg(pkt.json())\n\n\n  async function _init_handshake(chan_id) ::\n    const chan_send = _bind_send(opt, `${opt.topic}/c/${chan_id}`)\n    const rtc = RTCHandshake.create(chan_send)\n\n    rtc.has_ended.then @::\n      _by_chan.delete(chan_id)\n    _by_chan.set(chan_id, rtc)\n\n    if opt.on_connection ::\n      opt.on_connection(rtc.pc, chan_id)\n    return rtc\n\n\n\nexport function _rtc_mqtt_client(opt) ::\n  const _bind_send = opt.bind_send || _bind_mqtt_send\n  const _bind_recv = opt.bind_recv || _bind_mqtt_recv\n\n  const chan_id = opt.chan_id || Math.random().toString(36).slice(2)\n  const chan_send = _bind_send(opt, `${opt.topic}/m/${chan_id}`)\n\n  let rtc = RTCHandshake.create(chan_send)\n\n  _bind_recv @ opt, `${opt.topic}/c/${chan_id}`,\n    @\\ pkt ::>\n      await rtc.on_rtc_msg(pkt.json())\n\n  if opt.on_connection ::\n    opt.on_connection(rtc.pc, chan_id)\n\n  return rtc.rtc_initiate()\n\n\n\nfunction _bind_mqtt_send(opt, topic) ::\n  return opt.mqtt.json_send(topic)\n\nfunction _bind_mqtt_recv(opt, topic, on_pkt) ::\n  return opt.mqtt.subscribe_topic(topic, on_pkt)\n\n"],"names":[],"mappings":";;;EAGE;IACE;;EAEF;IACE;;EAEF;IACE;IACA;;EAEF,kBAAmB;IACjB,cAAc;IACd;OACK,MAAO;;;EAGd;QACK,UAAU,uBAAuB;;IAEpC;IACA;IACA,oBAAqB,cAAe;;IAEpC,iCAAkC;MAChC,6BAA8B;QAC5B,yBAA0B,uBAAwB;UAChD;;EAER;QACI;MACA;;EAEJ;YACQ;MACJ,KAAK,WAAW;QACd;;MAEF,KAAK,cAAc,OAAO,QAAQ,OAAO,QAAQ;QAC/C;;;EAGN;IACE;IACA;IACA;IACA;IACA;;EAEF;IACE;QACE;MACA;;IAEF;;QAEE;MACA;MACA;MACA;;EAEJ;IACE;IACA;;EAEF;IACE;UACI;QACA;eACK;QACL;WACC;MACH;;EAEJ;IACE,aAAc,YAAa;;;ECxE7B;;;EAGA;EACA;;;;EAIA;;;EAGA;EACA;;;;;EAKA;EACA;;EAEA;;EAEA,WAAY,KAAM,GAAG,UAAU,YAAY;;MAEvC;UACE;QACA;;MAEF;;;EAGJ;IACE,kCAAkC,GAAG,UAAU,KAAK,QAAQ,CAAC;IAC7D;;IAEA;MACE;IACF;;QAEE;MACA;IACF;;;;;EAKF;EACA;;EAEA;EACA,kCAAkC,GAAG,UAAU,KAAK,QAAQ,CAAC;;EAE7D;;EAEA,WAAY,KAAM,GAAG,UAAU,KAAK,QAAQ,CAAC;;MAEzC;;MAEF;IACA;;EAEF;;;;AAIF;EACE;;AAEF;EACE;;;;"}
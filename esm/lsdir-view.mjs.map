{"version":3,"file":"lsdir-view.mjs","sources":["../code/deps.jsy","../code/view_utils.jsy","../code/fetch_utils.jsy","../code/lsdir-view.jsy"],"sourcesContent":["import JSON5 from 'https://cdn.jsdelivr.net/npm/json5@2.1.1/dist/index.min.mjs'\nexport @{} JSON5\n\nexport function json5_human(json_src) ::\n  json_src = json_src.trim()\n  if '{' !== json_src[0] ::\n    json_src = `{${json_src}}`\n  return JSON5.parse @ json_src\n\n","\nexport const as_src_view = @!\n  const _cache = new Map()\n\n  const _as_view_class = baseElement => @\n    class SrcBaseElement extends baseElement ::\n      connectedCallback() ::\n        const src = this.textContent\n        this.textContent = ''\n        this._render_src(src, this.ownerDocument)\n\n      disconnectedCallback() ::\n\n      _render_src(src) ::\n        this.src = src\n\n      static initialize() ::\n        return this\n      static define_as(key) ::\n        const klass = this.initialize()\n        customElements.define @ key, klass\n        return klass\n\n  return @\\ baseElement ::\n    let res = _cache.get(baseElement)\n    if undefined === res ::\n      res = _as_view_class(baseElement)\n      _cache.set(baseElement, res)\n    return res\n\n\nexport function raf_batch(on_render) ::\n  let q=[], tid=null\n  return @\\ ...args ::\n    q.push(...args)\n    if null === tid ::\n      tid = requestAnimationFrame @ _batch\n\n  function _batch() ::\n    const batch = q\n    q=[]; tid=null\n    on_render(batch)\n\n\nexport const data_url = @\\ mime, src =>\n  `data:${mime},${encodeURIComponent(src)}`\nexport const svg_data_url = src =>\n  data_url @ 'image/svg+xml', src\n\n","import { json5_human } from './deps.jsy'\n\nexport @{} json5_human,\n\nexport async function fetch_as(kind, req) ::\n  req = await req\n  switch kind ::\n    case 'body':\n      return req.body\n\n    case 'blob':\n      return req.blob()\n\n    case 'ab': case 'arrayBuffer':\n      return req.arrayBuffer()\n\n    case 'u8': \n      return new Uint8Array @\n        await req.arrayBuffer()\n\n    case 'form': case 'formData': \n      return req.formData()\n\n    case 'json':\n      return req.json()\n\n    case 'json5':\n      return json5_human @\n        await req.text()\n\n    case 'src': case 'txt': case 'text': default:\n      return req.text()\n\n\nexport function fetch_cors_get(src, headers) ::\n  return fetch @ src, @{} method: 'GET', mode: 'cors', headers\n\nexport async function fetch_json(src, headers) ::\n  const req = await fetch_cors_get(src, headers)\n  return req.json()\n\nexport async function fetch_text(src, headers) ::\n  const req = await fetch_cors_get(src, headers)\n  return req.text()\n\n","import { json5_human } from './deps.jsy'\nimport { as_src_view, raf_batch } from './view_utils.jsy'\nimport { fetch_as, fetch_json, fetch_cors_get } from './fetch_utils.jsy'\n\nexport class LsDirView extends as_src_view(HTMLElement) ::\n  get src() :: return this.getAttribute @ 'src'\n  set src(v) ::\n    if v :: this.setAttribute @ 'src', v\n    else this.removeAttribute @ 'src'\n    this.update()\n\n  get prefix() :: return this.getAttribute @ 'prefix'\n  set prefix(v) ::\n    if v :: this.setAttribute @ 'prefix', v\n    else this.removeAttribute @ 'prefix'\n    this.update()\n\n  get mask() :: return this.getAttribute @ 'mask'\n  set mask(v) ::\n    if v :: this.setAttribute @ 'mask', v\n    else this.removeAttribute @ 'mask'\n    this.update()\n\n  async _render_src(cfg) ::\n    cfg = json5_human(cfg)\n\n    this.render_doc_view =\n      this._bind_render_doc_view @\n        cfg.views || cfg || {}\n\n    this.update()\n\n  update() ::\n    let cur = this._p_update\n    if undefined === cur ::\n      this._p_update = cur = this._update()\n    return cur\n\n  async _update() ::\n    await this\n    this.innerHTML = ''\n\n    const mask = this.as_mask_filter @ this.mask\n    const skip = this.as_prefix_filter @ this.prefix\n    const all_docs = await this.fetch_all @ this.src\n\n    const raf_q = raf_batch @ this._bind_batch()\n    for const [fname, doc] of await all_docs ::\n      if mask(doc.meta) :: continue\n      if skip(fname, doc) :: continue\n\n      raf_q @\n        await this.render_doc_view(doc)\n\n    this._p_update = undefined\n\n  _bind_batch() ::\n    return @\\ batch ::\n      for const elem of batch ::\n        this.appendChild(elem)\n\n  _bind_render_doc_view(views_by_ext) ::\n    const owner = this.ownerDocument\n    const fb_view = this.getAttribute('view')\n      || views_by_ext.fallback\n      || this.view_fallback\n\n    return async function render_doc_view(doc) ::\n      const ext = doc.fname.split('.').pop()\n\n      let attr='textContent', kind='text'\n      let view = views_by_ext[ext]\n        || views_by_ext['.'+ext]\n        || fb_view\n\n      if 'string' !== typeof view ::\n        [view, attr, kind] = view\n\n      const elem = owner.createElement @ view\n      elem[attr] = await fetch_as @ kind, doc.request\n      return elem\n\n\n  async fetch_all(src_path) ::\n    if ! src_path ::\n      src_path = 'all-docs.json'\n\n    const all_docs = await fetch_json @\n      src_path, this._fetch_headers\n    return all_docs.map @\n      this.fetch_doc.bind(this)\n\n\n  fetch_doc(doc) ::\n    const parts = doc.fname.split(/\\s*--\\s*/)\n    doc.name = parts.pop()\n    doc.prefix = parts.shift()\n    doc.meta = new Set @ parts\n\n    doc.request = fetch_cors_get @\n      doc.path, this._fetch_headers\n    return @[] doc.fname, doc\n\n  as_prefix_filter(prefix) ::\n    if ! prefix ::\n      return () => false\n\n    if prefix.endsWith('+') ::\n      prefix = prefix.replace(/\\+$/,'')\n      return fname => fname < prefix\n\n    return fname => ! fname.startsWith(prefix)\n\n  as_mask_filter(mask_keys) ::\n    mask_keys = mask_keys ? mask_keys.split(/\\s+/) : ['skip', 'hide']\n    return @\\ meta ::\n      for const k of mask_keys ::\n        if meta.has(k) ::\n          return true\n      return false\n\n\nObject.assign @ LsDirView.prototype, @{}\n  view_fallback: 'pre'\n  _fetch_headers: {}\n\ncustomElements.define @ 'lsdir-view', LsDirView\n\nexport default LsDirView\n\n"],"names":[],"mappings":";;;EAIE;MACG,GAAG;IACJ,WAAW,IAAI,SAAS;EAC1B,mBAAoB;;;ECLpB;;EAEA;IACE;MACE;QACE;QACA,mBAAmB;QACnB;;MAEF;;MAEA;QACE;;MAEF;QACE;MACF;QACE;QACA,sBAAuB;QACvB;;EAEN;IACE;QACE;MACA;MACA;IACF;;;AAGJ;EACE;EACA;IACE;QACE;MACA,4BAA6B;;EAEjC;IACE;IACA;IACA;;;ECpCF;UACM;IACJ,KAAK,MAAM;MACT;;IAEF,KAAK,MAAM;MACT;;IAEF,KAAK,IAAI,OAAO,aAAa;MAC3B;;IAEF,KAAK,IAAI;MACP;QACE;;IAEJ,KAAK,MAAM,OAAO,UAAU;MAC1B;;IAEF,KAAK,MAAM;MACT;;IAEF,KAAK,OAAO;MACV;QACE;;IAEJ,KAAK,KAAK,OAAO,KAAK,OAAO,MAAM;MACjC;;;AAGN;EACE,aAAc,KAAS,QAAS,KAAK,QAAQ,MAAM;;AAErD;EACE;EACA;;;EClCA,WAAY,yBAA2B;EACvC;QACI,IAAK,kBAAoB,KAAM;8BACN;IAC3B;;EAEF,cAAe,yBAA2B;EAC1C;QACI,IAAK,kBAAoB,QAAS;8BACT;IAC3B;;EAEF,YAAa,yBAA2B;EACxC;QACI,IAAK,kBAAoB,MAAO;8BACP;IAC3B;;EAEF;IACE;;IAEA;MACE;QACE;;IAEJ;;EAEF;IACE;QACE;MACA;IACF;;EAEF;IACE;IACA,iBAAiB;;IAEjB,iCAAkC;IAClC,mCAAoC;IACpC,sCAAuC;;IAEvC,wBAAyB;SACtB;UACC,iBAAkB;UAClB,mBAAoB;;MAEtB;QACE;;IAEJ;;EAEF;IACE;WACK;QACD;;EAEN;IACE;IACA,kCAAkC,MAAM;;;;IAIxC;MACE,4BAA4B,GAAG;;MAE/B,SAAS,aAAa,OAAO;MAC7B;wBACkB,GAAG;;;UAGlB,QAAQ;QACT;;MAEF,iCAAkC;MAClC,4BAA6B;MAC7B;;;EAGJ;QACK;MACD,WAAW;;IAEb;MACE;IACF;MACE;;;EAGJ;IACE,8BAA8B,UAAU;IACxC;IACA;IACA,mBAAoB;;IAEpB;MACE;IACF,QAAU;;EAEZ;QACK;MACD;;QAEA,gBAAiB,GAAG;MACpB,wBAAwB,KAAK,CAAC,EAAE;MAChC;;IAEF;;EAEF;IACE,wCAAwC,KAAK,KAAK,MAAM,EAAE,MAAM;IAChE;WACK;YACC;UACA;MACJ;;;AAGN,cAAe;EACb,eAAe;EACf;;AAEF,sBAAuB,YAAa;;;;;"}